## Components:

In React.js, a component is a reusable and self-contained piece of code that defines the structure and behavior of a part of a user interface. It represents a specific part or element of a web page or application. Components are the building blocks of a React application and can be composed together to create complex UIs.
A component can be thought of as a function or a class that returns a React element, which describes what should be rendered on the screen. Components can accept inputs called props (short for properties) that allow them to be configured and customized based on the application's needs.

## Functional components:

Functional components are simple JavaScript functions that accept props as an argument and return React elements.They are also known as stateless components because they do not manage their own state or have access to lifecycle methods. With the introduction of React Hooks in React 16.8, functional components can now also manage state and side effects.	

## Class components:

Class components are JavaScript classes that extend the React.Component class  and include a render method that returns React elements. They can also manage state and lifecycle methods, which makes them more suitable for complex components.

render(): The render() method is a required method in class components. It returns a React element or null, describing what should be rendered on the screen .React renders HTML to the web page by using a function called render(). The purpose of the function is to display the specified HTML code inside the specified HTML element. In the render() method, we can read props and state and return our JSX code to the root component of our app.	


 
## Virtual DOM:

React uses Virtual DOM which is like a lightweight copy of the actual DOM(a virtual representation of the DOM), it is the same, but it does not have the power to directly change the layout of the document. When the state or props of a component change, a new Virtual DOM tree is created. React compares the new Virtual DOM tree with the previous one to identify what has changed. This process is called "diffing." After identifying the differences, React updates the actual DOM to reflect the new state. It only updates the parts of the DOM that have changed, rather than re-rendering the entire DOM tree.

By using the Virtual DOM, React minimizes direct manipulation of the real DOM, leading to better performance, especially in applications with frequent updates.Direct DOM manipulation is slow because it often requires browser reflows and repaints. The Virtual DOM minimizes these operations by batching updates and applying them in a single, optimized step.

## JSX:
JSX stands for JavaScript XML. It allows developers to write HTML elements in JavaScript and place them in the DOM without using methods like createElement or appendChild. JSX makes it easier to write and understand the structure of the UI in React applications by providing a syntax that closely resembles HTML.

## React Hook: 

In React, a hook is a special function that lets you "hook into" React state and lifecycle features from function components. Hooks were introduced in React 16.8 to enable the use of state and other React features without writing a class component. The two most commonly used hooks are useState and useEffect.
Hooks provide a more straightforward and concise way to manage state, side effects, and other React features without the need for class components and complex lifecycle methods.

##Event:

An event is an action or occurrence that happens in the browser generated by user actions such as clicking, typing, moving the mouse, or by the browser itself, such as when a page loads or when an error occurs.

## Event Object:

The event object in JavaScript is an object that is automatically passed to event handlers when an event occurs. This object contains information about the event and the element that triggered it, allowing you to interact with and manipulate the event.

## State:

In React, "state" refers to a built-in object that holds data or information about the component, that can change over time, usually as a result of user actions or network responses. We can update state of a component by using React Hooks.

## useState() Hook:

The useState hook is one of the most commonly used hooks in React that allows you to add state to functional components , enabling them to manage and update data over time. The useState hook returns an array with two elements: the current state value and a function to update that value.

## useEffect() Hook:

The useEffect hook is one of the most commonly used hooks in React. It allows you to perform side effects in functional components, such as fetching data from an API, subscribing to events, or manipulating the DOM. SideEffects are basically anything that affects something outside of the scope of the current function thats's being executed. The useEffect hook is called after the component has rendered, and it runs on every subsequent re-render unless specified otherwise.

useEffect(effectFunction, dependencies);
The effectFunction parameter is the function that contains the side effect logic. It will be executed after the component renders and re-renders. The dependencies parameter is an optional array that allows you to specify the values that the effectFunction depends on. By providing dependencies, you can control when the effect should run. If the dependencies haven't changed since the last render, React will skip the effect.

Cleanup function: The useEffect hook can also return a cleanup function. This function will be executed before the component is unmounted or before the effect runs again (if the dependencies change). It's useful for cleaning up resources like canceling subscriptions, clearing timers, or removing event listeners. The cleanup function is particularly useful for handling scenarios where a component might unmount, and you need to ensure that no stale or unnecessary operations continue running to avoid memory leaks.

## ContextAPI:

The Context API is a useful tool for sharing data among multiple components without manually passing data through props. It is particularly suitable for use cases such as theming, user language, and authentication. This makes your components more decoupled and your code more manageable, maintainable and predictable.Context API in React helps maintain unidirectional data flow and encapsulation.

To begin working with the Context API, we first need to create a context by utilizing the createContext function from React.

Provider:
We will use the Provider component to wrap the components that require access to our context.The Provider component has a prop or value, which can be accessed from all components wrapped inside the Provider. It is responsible for providing access to the context data.

## useContext():

The useContext hook in React is used to access or consume the current context value created using the createContext API. Context provides a way to share data between components without manually passing props through every component tree level. The useContext hook allows functional components to consume the value of a context easily.Using the Context API and the useContext hook makes our code cleaner and easier to maintain than using the Consumer component.




## Redux:

 Redux (It is an open-source, JavaScript library useful in managing the application state) when it comes to the management of the global application state tree in large complex applications, even though the React will provide a useReducer hook that manages state transitions similar to Redux. Redux is very useful at a lower level of component hierarchy to handle the pieces of a state which are dependent on each other, instead of a declaration of multiple useState hooks.

In commercial web applications which is larger, the complexity will be high, so using only React Hook may not be sufficient. Few developers will try to tackle the challenge with the help of React Hooks and others will combine React Hooks with the Redux.

Store:

The store is a JavaScript object that holds the applicationâ€™s state.
It is the single source of truth in a Redux application.
The store is created using the createStore function and can be accessed by any component that needs to read or update the state.

State:

The state is the data or the application's state at a given point in time.
The state is stored in the store and can be updated only by dispatching actions.

Action:

Actions are plain JavaScript objects that describe what happened in the application.
Each action has a type property that indicates the type of action being performed. Optionally, actions can have additional data.
Actions are created using action creators, which are functions that return action objects.

Reducer:

A reducer is a pure function that takes the current state and an action as arguments and returns a new state.
Reducers specify how the application's state changes in response to actions.
Reducers must be pure functions, meaning they should not have side effects.

Dispatch:

The dispatch function is used to send actions to the store.
When an action is dispatched, the store runs the reducer to calculate the new state and updates the state accordingly.

Middleware:

Middleware is used to extend Redux with custom functionality.
It provides a way to intercept actions dispatched to the store before they reach the reducer.
Common use cases for middleware include handling asynchronous actions, logging, and crash reporting.

Provider:

The Provider component makes the Redux store available to the rest of the application.
It is typically used at the top level of the application
